<!DOCTYPE html>

<html lang="zh-CN">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta name="description" content="">
        <meta name="keywords" content="">

        <title>使用 makefile 来简化 c 文件的编译和链接</title>

        <link rel="stylesheet" href="/github_blog/public/bower_components/bootstrap/dist/css/bootstrap.min.css">
        <link rel="stylesheet" href="/github_blog/public/stylesheets/dest/style.min.css">

        <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
          <script src="//cdn.bootcss.com/html5shiv/3.7.2/html5shiv.min.js"></script>
          <script src="//cdn.bootcss.com/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->
    </head>

    <body>
        <div class="container post">
            <a href="/github_blog/">&lt;- Back to Home</a>
            <h2>使用 makefile 来简化 c 文件的编译和链接</h2>
            <p>虽然说我的主攻方向并不在 c 方面，但是多学点东西还是更好一点的，思路就更加广阔，并且日常生活中复习数据结构和算法的时候还是会使用 c 来刷题。</p>

<p>我使用的是 <code>Ubuntu15.04</code> ，以下的内容摘录于 鸟哥的linux私房菜 书籍并结合了自己的理解。</p>

<ul>
  <li>
    <p>首先先来介绍如果不通过 makefile 来编译和链接 c 程序：</p>

    <p>假设存在如下的两个文件：</p>

    <pre><code>  //thanks.c
  #include &lt;stdio.h&gt;
    
  int main(void)
    
  {
      printf("Hello world\n");
        
      thanks2();
        
      return 0;
  }
    
  //thanks2.c
  #include &lt;stdio.h&gt;
    
  void thanks2()
    
  {
      printf("Thanks you!\n");
        
      return;
  }
</code></pre>

    <p>接下来编译和链接：</p>

    <pre><code>  gcc -c thanks.c thanks2.c   //通过了执行这个命令之后，当前的目录中就会生成相应的 *.o 目标文件
    
  gcc -o thanks thanks.o thanks2.o  //链接生成可执行文件
</code></pre>

    <p>在这里讲解以下为什么不一步由源文件生成可执行文件，而要通过生成目标文件再来生成可执行文件？</p>

    <p>原因就是编译一个大型文件的时候，会花费很长的时间。如果有一天你更新了其中的一个文件内容，并且原本是通过生成目标文件的方式进行链接的话，这个时候的你就会感到十分的幸运，因为你只要重新编译你修改过的源文件来生成相应的目标文件，然后再以链接制出新的二进制可执行文件即可。不然如果你的文件数目很多并且每一个文件的内容又十分的多的时候，我就不确定你要编译多久了…</p>

    <p>其实在编译的过程中，我们可以通过添加适当的参数，使得程序在执行的时候具有比较好的性能以及一定的调试功能：</p>

    <pre><code>  -O 大写字母 O 为生成优化的参数，优化执行速度

  -Wall 添加这个参数可以产生更加详细的编译过程，输出警告信息

  -std=c99  对于加这个参数的原因，看看下面的编译错误信息就知道了
    
  →  ~/cLearn ✗✗✗ make
  cc -Wall -O    -c -o xm.o xm.c
  xm.c: In function ‘main’:
  xm.c:8:5: error: ‘for’ loop initial declarations are only allowed in C99 or C11 mode
       for ( int i=1; i&lt;=10; i++ ) 
       ^
  xm.c:8:5: note: use option -std=c99, -std=gnu99, -std=c11 or -std=gnu11 to compile your code
  &lt;builtin&gt;: recipe for target 'xm.o' failed
  make: *** [xm.o] Error 1
</code></pre>
  </li>
  <li>
    <p>使用 makefile 来编译和链接 c 程序</p>

    <p>先来看看我日常编译和链接 c 程序的 makefile 文件吧：</p>

    <pre><code>  OBJS = xm.o
  CFLAGS = -Wall -O -std=c99
    
  a : ${OBJS}
  	gcc -o xm ${OBJS} //注意这前面的缩进是 tab 
    
  x : 
  	./xm  //注意这前面的缩进是 tab
</code></pre>

    <p>使用(直接在 vim 编辑器的命令模式下输入下面的命令)：</p>

    <pre><code>  make a or make  //使用两者之一都可以对文件进行编译和链接
  make x  //执行这个命令可以执行文件
</code></pre>

    <p>从上面的文件内容可以看出来，我仅写出了目标文件，结果 make 会主动去判断和目标文件相关的源码文件，并直接予以编译，最后直接进行链接的操作。此外，如果我们改动过某些源码文件，则 make 也可以主动判断哪一个源码与相关的目标文件有更新过，并仅更新该文件，如此一来，将可大大的节省很多编译的时间。要知道，某些程序在进行编译的行为时，会消耗很多的 cpu 资源。</p>

    <p>因为我一般情况下不会使用到多文件，所以能体现出来的好处就是：我可以不用退出编辑器或者开多个窗口，直接使用 make 进行编译链接并执行文件。</p>

    <p>但是如果对于那些主攻 c 语言的人来说，多文件操作是很正常的事情，这时候就可以体现出来很多的好处了。</p>

    <p>下面简单的讲解一下  makefile 的基本语法与变量：</p>

    <ul>
      <li>
        <p>基本语法：</p>

        <pre><code>  目标(target) : 目标文件1 目标文件2
  &lt;tab&gt; gcc -o 欲新建的可执行文件 目标文件1 目标文件2
</code></pre>

        <p>看看上面我写的使用案例就知道基本语法的意思了。下面简单的讲解一下一些注意的事项：</p>

        <p>在 makefile 文件当中 <code>#</code> 代表批注；</p>

        <p><code>&lt;tab&gt;</code> 需要在命令行中的第一个字符；</p>

        <p>目标与相关文件之间需以 <code>:</code> 隔开；</p>
      </li>
      <li>
        <p>变量：</p>

        <p>其实上面我写的案例中还使用到了变量的知识。变量的作用就是用来处理重复出现的数据的。</p>

        <p>基本语法如下：</p>

        <p>变量与变量内容以 <code>=</code> 隔开来，同时两边可以具有空格；</p>

        <p>变量的左边不可以是 <code>&lt;tab&gt;</code>；</p>

        <p>变量与变量内容在 <code>=</code> 两边不能具有 <code>:</code>；</p>

        <p>在习惯上面，变量最好是以 <code>大写字母</code> 为主；</p>

        <p>使用变量的时候，以 <code>${变量}</code> 或 <code>$(变量)</code> 使用；</p>

        <p>还有一点要注意的是，编译的时候使用的参数都放在了 <code>CFLAGS</code> 这个环境变量当中，原因是 gcc 在进行编译的行为的时候，会主动的去读取这个变量的内容。</p>
      </li>
    </ul>
  </li>
</ul>

<p>欢迎指教=^_^=</p>


            <div id="disqus_thread"></div>
            <script type="text/javascript">
                /* * * CONFIGURATION VARIABLES * * */
                var disqus_shortname = 'jimmy-github-blog';
                
                /* * * DON'T EDIT BELOW THIS LINE * * */
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" rel="nofollow">comments powered by Disqus.</a></noscript>
        </div>
    </body>
</html>
